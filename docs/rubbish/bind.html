<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="icon" href="data:,">  <!-- 空图标 -->
</head>
<body>
    <script>
        Function.prototype.myBind = function(obj, ...args) {
            const fn = this; // 属于方法的调用 play.myBind();
            return function bindFn(...resArgs) {
                // 符合new的第三条：执行构造函数，this指向空对象
                // console.log('里层', this, JSON.stringify(this) === "{}");
                // if (Object.getPrototypeOf(this) === bindFn.prototype) {
                if (this instanceof bindFn) {
                    // return new fn(...args, ...resArgs);
                    // const obj = new Object();
                    // obj.__proto = fn.prototype;
                    // Object.setPrototypeOf(obj, fn.prototype); // 可优化，用Object.create()
                    const obj = Object.create(fn.prototype); // 这是创建原型继承的标准方式
                    // 比直接修改 __proto__ 更规范（__proto__ 是非标准属性）
                    const data = fn.call(obj, ...args, ...resArgs);
                    return typeof data === 'object' ? data: obj;
                } else {
                    return fn.call(obj, ...args, ...resArgs);
                }
            }
        }
        const obj = {
            name: 'Brunson',
            team: '尼克斯'
        }
        const play = function(coach, city) {
            // 符合new的第三条：执行构造函数，this指向空对象。
            console.log(this, JSON.stringify(this) === '{}', this.name, this.team, coach, city);
            return 888;
        }
        // 改变this, 多次传参，不立即调用
        const objBind = play.myBind(obj, '锡伯杜');
        const result = new objBind('纽约');
    </script>
</body>
</html>