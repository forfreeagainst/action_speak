<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="icon" href="data:,">  <!-- ç©ºå›¾æ ‡ -->
</head>
<body>
    <script>
        const PENDING = 'pending';
        const FULFILLED = 'fulfilled';
        const REJECTED = 'rejected';
        class MyPromise{
            #promiseState = PENDING;
            #promiseResult = null;

            #handlerList = [];
            constructor(executor) {
                try {
                    executor(this.resolve.bind(this), this.reject.bind(this));
                } catch(err) {
                    this.reject(err);
                }
            }
            runMicroTack(fn) {
                if (typeof process === 'object' && typeof process.nextTick === 'function') {
                    process.nextTick(fn);
                } else if (typeof MutationObserver === 'function') {
                    const ob = new MutationObserver(fn);
                    const textNode = document.createTextNode('1');
                    ob.observe(textNode, {
                        characterData: true
                    })
                    textNode.data = '2'
                } else {
                    setTimeout(fn,0)
                }
            }
            changeState(state, result) {
                if (this.#promiseState !== PENDING) return;
                this.#promiseState = state;
                this.#promiseResult = result;                
                if(this.#handlerList.length) {
                    let {onFulfilled, onRejected, resolve, reject} = this.#handlerList.shift();
                    // ä¸æ˜¯å‡½æ•°ï¼Œå®šä¹‰ æˆä¸€ä¸ªå‡½æ•°
                    // val => val;
                    // åŒ…è£…æˆä¸€ä¸ªå‡½æ•°
                    // function anonymous(val) {
                    //     return val
                    // }
                    onFulfilled = typeof onFulfilled !== 'function' ? val => val: onFulfilled;
                    onRejected = typeof onRejected !== 'function' ? err => err: onRejected;
                    try {
                        if (this.#promiseState === FULFILLED) {
                            // è¿™é‡Œæ‰æ‰§è¡Œ è¿™ä¸ªå‡½æ•°ã€‚
                            const data = onFulfilled(this.#promiseResult)
                            // resolve(data);
                            if (this.isPromise(data)) {
                                console.log('æ ‡è®°', data);
                                data.then(resolve, reject);
                            } else {
                                console.log('æ²¡æœ‰æ ‡è®°')
                                resolve(data);  
                            }
                        } else if (this.#promiseState === REJECTED) {
                            const data = onRejected(this.#promiseResult);
                            resolve(data);
                        }
                    } catch(err) {
                        reject(err)
                    }
                }
            }
            resolve(res) {
                this.changeState(FULFILLED, res);
            }
            reject(err) {
                this.changeState(REJECTED, err);
            }
            isPromise(obj) {
                if(obj !== null && (typeof obj === 'object' || typeof obj === 'function')) {
                return typeof obj.then === 'function';
                }
                return false;
            }
            // æˆåŠŸçŠ¶æ€è§¦å‘æˆåŠŸå›è°ƒï¼Œå¤±è´¥çŠ¶æ€è§¦å‘å¤±è´¥å›è°ƒã€‚
            then(onFulfilled, onRejected) {
                // console.log("ğŸš€ ~ MyPromise ~ then ~ onRejected:", onRejected)
                // console.log("ğŸš€ ~ MyPromise ~ then ~ onFulfilled:", onFulfilled)
                return new Promise((resolve, reject) => {
                    this.#handlerList.push({
                        onFulfilled,
                        onRejected,
                        resolve,
                        reject
                    })
                })
            }
        }
        // é“¾å¼è°ƒç”¨
        // new MyPromise((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve(100);
        //     },500)
        // }).then(res => res * 2, err=> console.log(err))
        // .then(res=> console.log(res), err=> console.log(err));

       
        // è¿”å›å€¼æ˜¯Promise.
        new MyPromise((resolve, reject) => {
            setTimeout(()=> {
                resolve(0)
            })
        }).then(res => {
            // é€šè¿‡setTimeoutç›´æ¥return 1010, åé¢çš„.thenè·å–åˆ°çš„res æ˜¯undefinedã€‚
            return new MyPromise((resolve, reject) => {
                setTimeout(() => {
                    resolve(1010);
                }, 1000)
            })
        })
        .then(res=> console.log(res, 'res2'), err=> console.log(err, 'err2')); // err2

        // character å½“ä¸º true æ—¶ï¼Œç›‘å¬å£°æ˜çš„ target èŠ‚ç‚¹ä¸Šæ‰€æœ‰å­—ç¬¦çš„å˜åŒ–ã€‚
    </script>
</body>
</html>